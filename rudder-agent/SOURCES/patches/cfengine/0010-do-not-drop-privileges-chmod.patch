From 19c1ad43ef9b80a11d1e4e06f2e3d00f2a0a2e89 Mon Sep 17 00:00:00 2001
From: Kristian Amlie <kristian.amlie@cfengine.com>
Date: Tue, 26 Jan 2016 09:53:59 +0100
Subject: [PATCH 1/2] Redmine #7808: Do not drop privileges when changes
 permissions on non fifo

The reason is that dropping privileges has some unexpected
consequences: CFEngine operates recursively on a file tree in a way
that may leave the directory being operated on last (e.g. files inside
the directory are treated before the directory itself). This means
that if we drop privileges, we may not always have the permissions to
enter the directory. This is impossible to fix for FIFOs (other than
changing the order that CFEngine does things, but that is on a
different code level and has other implications), because FIFOs will
block if we try to open a file descriptor to them, but we can fix it
for regular files by switching back to the old method of opening the
file descriptor and doing fchmod on that.

An additional level of complexity in this case is that the path may
end in a symlink *pointing* to a FIFO, hence the code that opens the
true parent directory of the leaf.

Changelog: Fix a regression which would sometimes cause "Permission
denied" errors on files inside directories with very restricted
permissions.

Based on a patch by Alexis Mousset <alexis.mousset@normation.com>.
---
 libutils/file_lib.c        | 147 +++++++++++++++++++++++++++------------------
 tests/unit/file_lib_test.c |   5 +-
 2 files changed, 92 insertions(+), 60 deletions(-)

diff --git a/libutils/file_lib.c b/libutils/file_lib.c
index 43ea298..0e1bdd3 100644
--- a/libutils/file_lib.c
+++ b/libutils/file_lib.c
@@ -657,10 +657,13 @@ int safe_chdir(const char *path)
 #ifndef __MINGW32__
 
 /**
- * Implementation of safe_chown.
- * @param path Path to chown.
- * @param owner          Owner to set on path.
- * @param group          Group to set on path.
+ * Opens the true parent dir of the file in the path given. The notable
+ * difference from doing it the naive way (open(dirname(path))) is that it
+ * can follow the symlinks of the path, ending up in the true parent dir of the
+ * path. It follows the same safe mechanisms as `safe_open()` to do so. If
+ * AT_SYMLINK_NOFOLLOW is given, it is equivalent to doing it the naive way (but
+ * still following "safe" semantics).
+ * @param path           Path to open parent directory of.
  * @param flags          Flags to use for fchownat.
  * @param link_user      If we have traversed a link already, which user was it.
  * @param link_group     If we have traversed a link already, which group was it.
@@ -670,10 +673,15 @@ int safe_chdir(const char *path)
  *                       Initially this is false, but will be set to true in
  *                       sub invocations if we follow a link.
  * @param loop_countdown Protection against infinite loop following.
+ * @return File descriptor pointing to the parent directory of path, or -1 on
+ *         error.
  */
-int safe_chown_impl(const char *path, uid_t owner, gid_t group, int flags,
-                    uid_t link_user, gid_t link_group, bool traversed_link,
-                    int loop_countdown)
+static int safe_open_true_parent_dir(const char *path,
+                                     int flags,
+                                     uid_t link_user,
+                                     gid_t link_group,
+                                     bool traversed_link,
+                                     int loop_countdown)
 {
     int dirfd = -1;
     int ret = -1;
@@ -738,21 +746,17 @@ int safe_chown_impl(const char *path, uid_t owner, gid_t group, int flags,
             free(link);
         }
 
-        ret = safe_chown_impl(resolved_link, owner, group, flags,
-                              statbuf.st_uid, statbuf.st_gid, true, loop_countdown);
+        ret = safe_open_true_parent_dir(resolved_link, flags, statbuf.st_uid,
+                                        statbuf.st_gid, true, loop_countdown);
 
         free(resolved_link);
         goto cleanup;
     }
 
     // We now know it either isn't a link, or we don't want to follow it if it
-    // is. In either case make sure we don't try to follow it.
-    flags |= AT_SYMLINK_NOFOLLOW;
-
-    if ((ret = fchownat(dirfd, leaf, owner, group, flags)) == -1)
-    {
-        goto cleanup;
-    }
+    // is. Return the parent dir.
+    ret = dirfd;
+    dirfd = -1;
 
 cleanup:
     free(parent_dir_alloc);
@@ -766,6 +770,42 @@ int safe_chown_impl(const char *path, uid_t owner, gid_t group, int flags,
     return ret;
 }
 
+/**
+ * Implementation of safe_chown.
+ * @param path Path to chown.
+ * @param owner          Owner to set on path.
+ * @param group          Group to set on path.
+ * @param flags          Flags to use for fchownat.
+ * @param link_user      If we have traversed a link already, which user was it.
+ * @param link_group     If we have traversed a link already, which group was it.
+ * @param traversed_link Whether we have traversed a link. If this is false the
+ *                       two previus arguments are ignored. This is used enforce
+ *                       the correct UID/GID combination when following links.
+ *                       Initially this is false, but will be set to true in
+ *                       sub invocations if we follow a link.
+ * @param loop_countdown Protection against infinite loop following.
+ */
+int safe_chown_impl(const char *path, uid_t owner, gid_t group, int flags)
+{
+    int dirfd = safe_open_true_parent_dir(path, flags, 0, 0, false, SYMLINK_MAX_DEPTH);
+    if (dirfd < 0)
+    {
+        return -1;
+    }
+
+    char *leaf_alloc = xstrdup(path);
+    char *leaf = basename(leaf_alloc);
+
+    // We now know it either isn't a link, or we don't want to follow it if it
+    // is. In either case make sure we don't try to follow it.
+    flags |= AT_SYMLINK_NOFOLLOW;
+
+    int ret = fchownat(dirfd, leaf, owner, group, flags);
+    free(leaf_alloc);
+    close(dirfd);
+    return ret;
+}
+
 #endif // !__MINGW32__
 
 /**
@@ -780,8 +820,7 @@ int safe_chown(const char *path, uid_t owner, gid_t group)
 #ifdef __MINGW32__
     return chown(path, owner, group);
 #else // !__MINGW32__
-    return safe_chown_impl(path, owner, group, 0,
-                           0, 0, false, SYMLINK_MAX_DEPTH);
+    return safe_chown_impl(path, owner, group, 0);
 #endif // !__MINGW32__
 }
 
@@ -795,8 +834,7 @@ int safe_chown(const char *path, uid_t owner, gid_t group)
 #ifndef __MINGW32__
 int safe_lchown(const char *path, uid_t owner, gid_t group)
 {
-    return safe_chown_impl(path, owner, group, AT_SYMLINK_NOFOLLOW,
-                           0, 0, false, SYMLINK_MAX_DEPTH);
+    return safe_chown_impl(path, owner, group, AT_SYMLINK_NOFOLLOW);
 }
 #endif // !__MINGW32__
 
@@ -814,14 +852,12 @@ int safe_chmod(const char *path, mode_t mode)
     int dirfd = -1;
     int ret = -1;
 
-    char *parent_dir_alloc = xstrdup(path);
     char *leaf_alloc = xstrdup(path);
-    char *parent_dir = dirname(parent_dir_alloc);
     char *leaf = basename(leaf_alloc);
     struct stat statbuf;
     uid_t olduid = 0;
 
-    if ((dirfd = safe_open(parent_dir, O_RDONLY)) == -1)
+    if ((dirfd = safe_open_true_parent_dir(path, 0, 0, 0, false, SYMLINK_MAX_DEPTH)) == -1)
     {
         goto cleanup;
     }
@@ -831,57 +867,54 @@ int safe_chmod(const char *path, mode_t mode)
         goto cleanup;
     }
 
-    /* save old euid */
-    olduid = geteuid();
-
-#ifndef CHMOD_SETEUID_WORKS
-    if (mode & 07000 && statbuf.st_uid != 0)
+    if (S_ISFIFO(statbuf.st_mode))
     {
-        /* If we get here, we are on a platform where the high bit flags (sticky
-           bit and suid) flags cannot be set by any other users than root. But
-           doing so is insecure because someone can replace the file with a link
-           to a sensitive file. Fall back to opening the file with safe_open
-           first. If the file is a FIFO, we give up because opening it might
-           block, in that case it's not possible to do it securely. Setting the
-           mentioned flags on a FIFO should be extremely rare though.
-        */
-        if (S_ISFIFO(statbuf.st_mode))
+#ifdef CHMOD_SETEUID_WORKS
+        /* save old euid */
+        olduid = geteuid();
+
+        if ((ret = seteuid(statbuf.st_uid)) == -1)
         {
-            errno = ENOTSUP;
-            ret = -1;
             goto cleanup;
         }
 
-        int file_fd = safe_open(path, 0);
-        if (file_fd < 0)
+        ret = fchmodat(dirfd, leaf, mode, 0);
+
+        // Make sure EUID is set back before we check error condition, so that we
+        // never return with lowered privileges.
+        if (seteuid(olduid) == -1)
         {
-            ret = -1;
-            goto cleanup;
+            ProgrammingError("safe_chmod: Could not set EUID back. Should never happen.");
         }
 
-        ret = fchmod(file_fd, mode);
-        close(file_fd);
         goto cleanup;
-    }
-#endif // !CHMOD_SETEUID_WORKS
+#endif // CHMOD_SETEUID_WORKS
 
-    if ((ret = seteuid(statbuf.st_uid)) == -1)
-    {
-        goto cleanup;
+        if (mode & 07000 && statbuf.st_uid != 0)
+        {
+            /* If we get here, we are on a platform where the high bit flags (sticky
+               bit and suid) flags cannot be set by any other users than root. As the
+               file is a FIFO, we give up because opening it might block, in that
+               case it's not possible to do it securely. Setting the mentioned flags
+               on a FIFO should be extremely rare though.
+            */
+            errno = ENOTSUP;
+            ret = -1;
+            goto cleanup;
+        }
     }
 
-    ret = fchmodat(dirfd, leaf, mode, 0);
-
-    // Make sure EUID is set back before we check error condition, so that we
-    // never return with lowered privileges.
-    if (seteuid(olduid) == -1)
+    int file_fd = safe_open(path, 0);
+    if (file_fd < 0)
     {
-        ProgrammingError("safe_chmod: Could not set EUID back. Should never happen.");
+        ret = -1;
+        goto cleanup;
     }
 
+    ret = fchmod(file_fd, mode);
+    close(file_fd);
 
 cleanup:
-    free(parent_dir_alloc);
     free(leaf_alloc);
 
     if (dirfd != -1)
diff --git a/tests/unit/file_lib_test.c b/tests/unit/file_lib_test.c
index 13a9377..ea484bb 100644
--- a/tests/unit/file_lib_test.c
+++ b/tests/unit/file_lib_test.c
@@ -1236,7 +1236,7 @@ static void test_safe_chmod_unsafe_link(void)
     assert_int_equal(stat(TEST_SUBDIR "/" TEST_FILE, &statbuf), 0);
     assert_int_equal(statbuf.st_mode & 0777, 0777);
     assert_int_equal(safe_chmod(TEST_FILE, 0644), -1);
-    assert_int_equal(errno, EPERM);
+    assert_int_equal(errno, ENOLINK);
     assert_int_equal(stat(TEST_SUBDIR "/" TEST_FILE, &statbuf), 0);
     assert_int_equal(statbuf.st_mode & 0777, 0777);
 
@@ -1320,8 +1320,7 @@ static void test_safe_chmod_chown_fifos(void)
     assert_int_equal(safe_chown(TEST_FILE, 100, 100), -1);
     assert_int_equal(errno, ENOLINK);
     assert_int_equal(safe_chmod(TEST_FILE, 0755), -1);
-    // Would be ENOLINK, but safe_chmod lacks support for detecting this.
-    assert_int_equal(errno, EPERM);
+    assert_int_equal(errno, ENOLINK);
     assert_int_equal(safe_chown(TEST_SUBDIR "/" TEST_FILE, 100, 100), 0);
 
     // Now the owner is correct

From 8ef0129a70ad6f94498ce99bdd5cd5367dffe4d7 Mon Sep 17 00:00:00 2001
From: Jonathan Clarke <jonathan.clarke@normation.com>
Date: Sun, 6 Dec 2015 14:31:34 +0100
Subject: [PATCH 2/2] Refs #7808: add test for recursive permissions change

---
 .../10_files/02_maintain/perms_recurse.cf          | 96 ++++++++++++++++++++++
 1 file changed, 96 insertions(+)
 create mode 100644 tests/acceptance/10_files/02_maintain/perms_recurse.cf

diff --git a/tests/acceptance/10_files/02_maintain/perms_recurse.cf b/tests/acceptance/10_files/02_maintain/perms_recurse.cf
new file mode 100644
index 0000000..1602d8d
--- /dev/null
+++ b/tests/acceptance/10_files/02_maintain/perms_recurse.cf
@@ -0,0 +1,96 @@
+# https://dev.cfengine.com/issues/7808
+#
+
+body common control
+{
+  inputs => { "../../default.cf.sub" };
+  bundlesequence  => { default("$(this.promise_filename)") };
+  version => "1.0";
+}
+
+bundle agent init
+{
+  meta:
+      # Permissions test doesn't work with fakeroot
+      "test_skip_needs_work" string => "using_fakeroot";
+
+  vars:
+      "directory" string => "$(G.testdir)";
+
+      "mode"      string => "750";
+      "owner"     string => "bin";
+      "group"     string => "bin";
+
+  files:
+      "$(directory)/."
+          perms  => mog("000", "root", "0"),
+          create => "true";
+
+      "$(directory)/dir1/."
+          perms  => mog("000", "root", "0"),
+          create => "true";
+
+      "$(directory)/dir2/."
+          perms  => mog("000", "root", "0"),
+          create => "true";
+
+}
+
+bundle agent test
+{
+  files:
+      "$(init.directory)"
+          create       => "false",
+          perms        => mog("${init.mode}", "${init.owner}", "${init.group}"),
+          depth_search => recurse_with_base("inf"),
+          file_select  => dirs;
+}
+
+body file_select dirs
+# @brief Select directories
+{
+    file_types  => { "dir" };
+    file_result => "file_types";
+}
+
+
+bundle agent check
+{
+
+  vars:
+    "permissions_test_mode"  string => "/usr/bin/test \"`/usr/bin/find ${init.directory} -perm ${init.mode} | wc -l`\" = \"3\"";
+    "permissions_test_owner" string => "/usr/bin/test \"`/usr/bin/find ${init.directory} -user ${init.owner} | wc -l`\" = \"3\"";
+    "permissions_test_group" string => "/usr/bin/test \"`/usr/bin/find ${init.directory} -group ${init.group} | wc -l`\" = \"3\"";
+
+  commands:
+    "${permissions_test_mode}"
+        contain => in_shell,
+        classes => ok("permissions_test_mode_ok");
+    "${permissions_test_owner}"
+        contain => in_shell,
+        classes => ok("permissions_test_owner_ok");
+    "${permissions_test_group}"
+        contain => in_shell,
+        classes => ok("permissions_test_group_ok");
+
+  reports:
+    DEBUG.!permissions_test_mode_ok::
+      "Didn't find 3 files with mode ${init.mode}";
+    DEBUG.!permissions_test_owner_ok::
+      "Didn't find 3 files with owner${init.owner}";
+    DEBUG.!permissions_test_group_ok::
+      "Didn't find 3 files with group ${init.group}";
+    permissions_test_mode_ok.permissions_test_owner_ok.permissions_test_group_ok::
+      "$(this.promise_filename) Pass";
+    !(permissions_test_mode_ok.permissions_test_owner_ok.permissions_test_group_ok)::
+      "$(this.promise_filename) FAIL";
+
+}
+
+body classes ok(classname)
+{
+    promise_repaired => { "$(classname)" };
+    promise_kept => { "$(classname)" };
+}
+
+
